
---

# ✅ 문자열 리터럴과 JVM의 동작

코드에서 아래와 같이 작성하면:

```java
lists.add("1");
```

여기서 `"1"`은 **문자열 리터럴**입니다. 문자열 리터럴은 자바가상머신(JVM)이 로딩할 때 특정한 방식으로 처리됩니다.

---

# ✅ 문자열 리터럴을 JVM이 만나면 어떻게 처리될까?

### 1. **컴파일 시 문자열 풀(String Pool)에 저장**

자바에서 문자열 리터럴 `"1"`을 만나면, JVM은 일반적으로 그 값을 **String Constant Pool**(또는 Intern Pool)에 저장합니다.

### 2. **String 객체가 생성되거나 재사용됨**

* `"1"`이라는 문자열이 이전에 풀에 존재하지 않으면 새로 생성해 넣고
* 이미 존재하면 **기존 객체를 재사용**합니다.

✅ 즉, 같은 내용의 문자열 리터럴은 메모리에 **중복으로 생성되지 않습니다.**

---

# ✅ "파싱한다"라는 표현은?

문장:

> "문자열 리터럴을 자바가상머신이 만나면 파싱한다"

여기서 **파싱한다**는 표현은 약간 부정확할 수 있습니다.

JVM이 실제로 하는 일은:

* 클래스를 로딩할 때 `.class` 파일에 기록된 문자열 리터럴을 읽어들이는 과정
* 상수 풀(constant pool)에 저장
* 실행 단계에서 필요할 때 해당 String 객체를 참조

**즉, 일반적인 의미의 '파싱(parse)'라기보다는 '로드(load)하고 관리(manage)'한다고 보는 것이 더 정확합니다.**

---

# ✅ lists.add("1") 실행 순서 상세 버전

1. `"1"` 문자열 리터럴이 클래스 로딩 시 String Pool에 저장됨 (또는 풀에서 검색됨).
2. 실행 시 `"1"`이 이미 있는 String 객체의 참조가 반환됨.
3. `lists.add()`에 전달되어 List에 저장됨.

---

# ✅ 중요한 포인트

### 문자열 리터럴 `"1"`은 new String("1")과 다릅니다!

```java
String s1 = "1";
String s2 = "1";

System.out.println(s1 == s2); // true
```

두 변수는 **같은 객체를 참조**합니다.

반면:

```java
String s3 = new String("1");
String s4 = new String("1");

System.out.println(s3 == s4); // false
```

새 String 객체 2개가 각각 생성됨.

---

# ✅ 정리

* 문자열 리터럴은 JVM이 클래스 로딩 시 **String Constant Pool**에 저장하거나 재사용함
* "파싱한다"는 표현보다 "**풀에 넣고 관리한다**"라는 표현이 더 정확함
* lists.add("1")는 이미 만들어진(또는 풀에서 가져온) String 객체를 리스트에 추가하는 것

---


